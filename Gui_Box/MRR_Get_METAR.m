function [ stormData, stormPage ] = MRR_Get_METAR( date_range, settings )
%MRR_GET_METAR Obtain METAR observations for storms recorded by MRR.
%   SUMMARY:
%       This function takes in a date range of serial dates given by
%       MRR_Storm_Detection.m, in addition to a settings variable, and gets
%       the necessary observations from METAR data to fill the webpage
%       table and the storm page table, as well as generate the 6
%       statistical images for: pressure, temperature, relative humidity,
%       wind speed, wind direction, and precipitation. This function uses
%       gen_metar2struct.m to convert a METAR txt file to a usable Matlab
%       struct. Alternatively, a .mat file containing the Matlab struct can
%       be provided in the settings struct using the field metarfile_mat.
%       Note: If a .mat file is provided, the Matlab struct of the metar
%       data should be called 'metarStruct'.
%
%   INPUTS:
%       MRR - Matlab struct containing MRR values of dBZ and doppler
%             velocity. 
%       date_range - Matlab struct containing a list of start and end
%                    serial dates for storms in MRR data.
%       settings - Important Matlab struct containing necessary fields:
%           metarfile_mat - metarfile_mat is a .mat file that contains the
%                           metarStruct variable generated by the
%                           gen_metar2struct.m function. If metarfile_mat
%                           is specified, metarfile and metar_interval will
%                           be ignored (OPTIONAL! IF UNSPECIFIED, MUST
%                           SPECIFY metarfile AND metar_interval).
%           metarfile - See metarfilepath in gen_metar2struct.m (ONLY USED
%                       IF metarfile_mat IS UNSPECIFIED).
%           metar_interval - See minuteinterval in gen_metar2struct.m (ONLY
%                       USED IF metarfiel_mat IS UNSPECIFIED).
%           choose_graphs - Set this to 1 in order to choose which METAR
%                           variables you would like to graph. Then, set
%                           any of the following fields to 1 to make the
%                           function graph that variable:
%                   fields: graph_pres - Pressure
%                           graph_temp - Temperature
%                           graph_wspd - Wind Speed
%                           graph_wdir - Wind Direction
%                           graph_relhum - Relative Humidity
%                           graph_precip - Precipitation
%                   NOTE: If you set one of the above fields but don't set
%                   choose_graphs, the function will produce graphs for all
%                   the variables.
%
%   OUTPUTS:
%       stormData - A struct containing information that goes in the table
%                   of storms on the website.
%       stormPage - A struct containing information that goes in the storm
%                   page of the storms on the website.
%   
%   REQUIRED SUB-FUNCTIONS:
%       gen_metar2struct.m
%
%   AUTHOR: Spencer Rhodes (srrhodes@ncsu.edu)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This code is part of a suite of software developed under the guidance of
% Dr. Sandra Yuter and the Cloud Precipitation Processes and Patterns Group
% at North Carolina State University.
% Copyright (C) 2013 Spencer Rhodes and Andrew Hall
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Initialize a struct array for stormData
stormData = struct([]);
stormPage = struct([]);
TITLE_FONT = {'FontSize' 30 'FontWeight' 'bold'};
AXES_FONT = {'FontSize' 14};

% Get the metar struct from gen_store_metar_values.m or metarfile_mat if
% specified in settings.
if isfield(settings, 'metarfile_mat')
    fprintf('Loading Matlab struct of METAR Data...')
    load(settings.metarfile_mat)
    fprintf('complete.\n')
else
    metarStruct = gen_metar2struct(settings.metarfile, 0, 0, settings.metar_interval);
end

% First get the alternate start times for each storm. Meaning, it is
% desirable for the graphs of temperature, wind speed, pressure, etc, to
% include at least ~12 hours of data before the storm. The end of the storm
% does not require extra room, only that the graph extends to the end of
% the day that the storm ends on. Similarly, the start time will always be
% on the beginning of a day. If the start time of the storm is before 12
% UTC, then the starting point of the graphs will be at the start of the
% previous day. If not, then the starting point of the graphs will simply
% be at the start of the day of the storm.
graphstart = zeros(1,length(date_range));
graphend = zeros(1,length(date_range));
for i = 1:length(date_range)
    vstart = datevec(date_range(i).start);
    if vstart(4) <= 12 % Start time is at or before 12 UTC
        % Sets graph start to beginning of PREVIOUS day
        vstart(4) = 0; vstart(5) = 0; vstart(6) = 0;
        graphstart(i) = datenum(vstart) - 1;
    else
        % Sets graph start to beginning of the day
        vstart(4) = 0; vstart(5) = 0; vstart(6) = 0;
        graphstart(i) = datenum(vstart);
    end

    vend = datevec(date_range(i).end);
    % Sets graph end to the end of the day of the storm's end.
    vend(4) = 0; vend(5) = 0; vend(6) = 0;
    graphend(i) = datenum(vend) + 1;
end

% Determine the hour duration and day duration of the graphs to be
% generated. Include a string of the Storm graphs title in the stormData
% struct to return back to the MRR_Add_Storms function for later use.
graphdur = zeros(1,length(date_range));
for i = 1:length(date_range)
    graphdur(i) = graphend(i) - graphstart(i);
    
    startmonth = datestr(graphstart(i), 'mmmm');
    startday = num2str(str2double(datestr(graphstart(i), 'dd')));
    if graphdur(i) == 1
        stormData(i).othergraphs_title = ['1-day Graph: ' ...
            startmonth ' ' startday];
    else
        endmonth = datestr(graphend(i), 'mmmm');
        endday = num2str(str2double(datestr(graphend(i), 'dd')) - 1);
        stormData(i).othergraphs_title = [num2str(graphdur(i)) ...
            '-day Graphs: ' startmonth ' ' startday ' - ' endmonth ' ' endday];
    end
end

% Initialize useful variables for parsing the metar data.
counter = 1;            % Tracks index of metarStruct
foundstart = 0;         % Tracks if reached storm in metarStruct
foundgraphstart = 0;    % Tracks if reached graph in metarStruct
foundgap = 0;           % Tracks if a gap was found at the beginning of a storm
stormid = 1;            % Tracks which storm to examine in date_range

%%% Variables to keep track of:
pressure = zeros(1, (24 * graphdur(stormid)) + 1);
temperature = zeros(1, (24 * graphdur(stormid)) + 1);
relhumidity = zeros(1, (24 * graphdur(stormid)) + 1);
windspd = zeros(1, (24 * graphdur(stormid)) + 1);
windspdWildcat = zeros(1, (24 * graphdur(stormid)) + 1);
gustsWildcat = zeros(1, (24 * graphdur(stormid)) + 1);
gusts = struct([]);
winddir = zeros(1, (24 * graphdur(stormid)) + 1);
totalprecip = 0; had_trace = 0;
precip = zeros(1, (24 * graphdur(stormid)) + 1);

fprintf('Parsing Matlab struct of METAR data\n')
fprintf('and generating graphs of statistics...\n')
% Parse the metar data and look for storms specified by the date_range.
% When parsing, first the start of the graph of a storm is found. Then the
% start of the storm is found. After the storm has ended, the graph may
% end. It is possible for the end of a graph of a storm to go past the
% beginning of a graph of the next storm in the date_range. This
% possibility is accounted for in the while loop.
while stormid <= length(date_range)
    % Date and time of the metar data being examined.
    serialdate = metarStruct(counter).date;
    
    % Check for gap in METAR data and fill the graph statistics with
    % corresponding NaN's.
    if foundgraphstart && counter > 1 && ~foundgap && serialdate ~= graphstart(stormid) && ...
            serialdate - (metarStruct(counter - 1).date + (1/24)) > (0.0415) % Approx 1 hour
        dif = round((serialdate - metarStruct(counter - 1).date) * 24 - 1);
        for k = 1:dif
            graphcounter = graphcounter + 1;
            if graphcounter > (24 * graphdur(stormid) + 1)
                break
            end
            pressure(graphcounter) = NaN;
            temperature(graphcounter) = NaN;
            relhumidity(graphcounter) = NaN;
            windspd(graphcounter) = NaN;
            winddir(graphcounter) = NaN;
            precip(graphcounter) = NaN;
        end
    end
    
    if foundgap
        foundgap = 0; % Reset found gap after first use above ^^
    end
    
    % Checks if the date of the of the metar data being looked at matches
    % or comes within one hour of the storm end time. Store all the values
    % obtained from the metar data into the stormData struct. By
    % definition, this conditional can execute only once per storm.
    if serialdate - date_range(stormid).end >= 0 && foundgraphstart >= 0
        foundstart = 0;
        foundgraphstart = -1; % Makes it so the above elseif statement does
                              % not execute more than once during a graph.
        
        if graphcounter < (24 * graphdur(stormid) + 1)
%             if ~isfield(settings, 'is_alta')
                pressure(graphcounter + 1) = metarStruct(counter).pres;
%             end
            temperature(graphcounter + 1) = metarStruct(counter).temp;
            relhumidity(graphcounter + 1) = metarStruct(counter).relhum;
            windspd(graphcounter + 1) = metarStruct(counter).wspd;
            if isfield(settings, 'is_alta')
                windspdWildcat(graphcounter + 1) = metarStruct(counter).wildcatWspd;
                gustsWildcat(graphcounter + 1) = metarStruct(counter).wildcatGust;
            end
%             gusts(graphcounter + 1).value = metarStruct(counter).gust;
            gusts(graphcounter + 1).date = serialdate;
            if isnan(metarStruct(counter).wdir) % Variable winds
                winddir(graphcounter + 1) = NaN;
            else
                winddir(graphcounter + 1) = metarStruct(counter).wdir;
            end
            if isnan(metarStruct(counter).precip1) % No precipitation
                precip(graphcounter + 1) = NaN;
            elseif metarStruct(counter).precip1 == -1 % Trace amount
                precip(graphcounter + 1) = 0;
            else
                precip(graphcounter + 1) = metarStruct(counter).precip1;
            end
        end
        
        if isfield(settings, 'is_alta')
            totalprecip = metarStruct(counter).precipY - beginningprecip;
            clear beginningprecip
        else
            % Update the total precipitation count for the final time.
%             if stormcounter > 24 && metarStruct(counter).precip24 > 0
%                 totalprecip = totalprecip + metarStruct(counter).precip24;
% 
%                 % Subtract the 6 hour precip counts that were added to the
%                 % totalprecip count in the 24 hour window.
%                 for j = (counter - 23):counter
%                     if metarStruct(j).precip6 > 0
%                         totalprecip = totalprecip - metarStruct(j).precip6;
%                     end
%                 end
%             end
%             if stormcounter > 6 && metarStruct(counter).precip6 > 0
%                 totalprecip = totalprecip + metarStruct(counter).precip6;
% 
%                 % Subtract the 1 hour precip counts that were added to the
%                 % totalprecip count in the 6 hour window.
%                 for j = (counter - 5):counter
%                     if metarStruct(j).precip1 > 0
%                         totalprecip = totalprecip - metarStruct(j).precip1;
%                     end
%                 end
%             end
            if metarStruct(counter).precip1 > 0
                totalprecip = totalprecip + metarStruct(counter).precip1;

            elseif metarStruct(counter).precip1 < 0
                had_trace = 1;

            end
        end
        
        % Get the subset of the arrays of data that belong to the storm:
        stormstart = datevec(date_range(stormid).start);
        stormend = datevec(date_range(stormid).end);
        stormstart(6) = 0; stormend(6) = 0;
        if stormstart(5) ~= 0
            stormstart(5) = 0; stormstart(4) = stormstart(4) + 1;
        end
        if stormend(5) ~= 0
            stormend(5) = 0; stormend(4) = stormend(4) + 1;
        end
        stormstart = datenum(stormstart);
        stormend = datenum(stormend);
        % Convert stormstart and stormend to indices for statisic arrays.
        stormstart = floor(24 * (stormstart - graphstart(stormid)) + 1);
        stormend = floor(24 * (stormend - graphstart(stormid)) + 1);
        
%         % Used to obtain the wind direction at storm maturity.
        s_winddir = winddir(stormstart:stormend);
%         s_gusts = [gusts(stormstart:stormend).value];
        s_windspd = windspd(stormstart:stormend);
%         s_gusts_wildcat = gustsWildcat(stormstart:stormend);
%         s_windspd_wildcat = windspdWildcat(stormstart:stormend);
        
        %%% Values for the table:
        stormData(stormid).year = datestr(date_range(stormid).start, 'yyyy');
        stormData(stormid).month = datestr(date_range(stormid).start, 'mm');
        stormData(stormid).day = datestr(date_range(stormid).start, 'dd');
        stormData(stormid).start = datestr(date_range(stormid).start, 'HH:MM');
        % Find duration of the storm
        difvector = datevec(date_range(stormid).end - date_range(stormid).start);
        stormData(stormid).duration = round(10 * (24 * difvector(3) + difvector(4) + difvector(5) / 60)) / 10;
        stormData(stormid).type = [];       % Not implemented.
        stormData(stormid).AGL = [];        % Not implemented.
        stormData(stormid).continuity = []; % Not implemented.
        stormData(stormid).avg_temp = nanmean(temperature(stormstart:stormend));
        stormData(stormid).avg_winddir = gen_calculate_avgwdir(s_winddir);
%         if ~isnan(max(s_gusts))
%             stormData(stormid).peak_winddir = winddir(stormstart + find(s_gusts == max(s_gusts),1) - 1);
        if ~isnan(max(s_windspd)) && max(s_windspd) ~= 0
            stormData(stormid).peak_winddir = winddir(stormstart + find(s_windspd == max(s_windspd),1) - 1);
        else
            stormData(stormid).peak_winddir = []; % No wind, therefore no peak winddir.
        end
        stormData(stormid).wind_speed = nanmean(s_windspd);
        if isfield(settings, 'is_alta')
            stormData(stormid).wind_speed_wildcat = nanmean(s_windspd_wildcat);
        end
        if totalprecip == 0 && had_trace
            stormData(stormid).precip = 'trace';
        else
            stormData(stormid).precip = totalprecip;
        end
        
        %%% Values for storm page:
        stormPage(stormid).start = date_range(stormid).start;
        stormPage(stormid).avgwdir = gen_calculate_avgwdir(s_winddir);
        stormPage(stormid).avgtemp = nanmean(temperature(stormstart:stormend));
        stormPage(stormid).avgpres = nanmean(pressure(stormstart:stormend));
        stormPage(stormid).avgrh = nanmean(relhumidity(stormstart:stormend));
        stormPage(stormid).avgwsp = nanmean(s_windspd);
        stormPage(stormid).maxtemp = max(temperature(stormstart:stormend));
        stormPage(stormid).maxpres = max(pressure(stormstart:stormend));
%         if ~isnan(max(s_gusts))
%             stormPage(stormid).maxwsp = max(s_gusts);
%         else
            stormPage(stormid).maxwsp = max(s_windspd);
%         end
        stormPage(stormid).maxrh = max(relhumidity(stormstart:stormend));
        stormPage(stormid).mintemp = min(temperature(stormstart:stormend));
        stormPage(stormid).minpres = min(pressure(stormstart:stormend));
        stormPage(stormid).minwsp = min(s_windspd);
        stormPage(stormid).minrh = min(relhumidity(stormstart:stormend));
%         if isfield(settings, 'is_alta')
%             stormPage(stormid).maxwspWildcat = max(s_gusts_wildcat);
%             stormPage(stormid).avgwspWildcat = nanmean(s_windspd_wildcat);
%             stormPage(stormid).minwspWildcat = min(s_windspd_wildcat);
%         end
        stormPage(stormid).othergraphs_title = stormData(stormid).othergraphs_title;
        % Set the strings for the images in the stormpage html file.
        graphstring = datestr(date_range(stormid).start, 'yyyymmdd_HHMM');
        stormData(stormid).graphstr = graphstring;
        stormPage(stormid).main_graph = [graphstring '.png'];
        stormPage(stormid).temp_graph = [graphstring '_temp.png'];
        stormPage(stormid).wsp_graph = [graphstring '_wsp.png'];
        stormPage(stormid).hpa_graph = [graphstring '_pres.png'];
        stormPage(stormid).rh_graph = [graphstring '_rh.png'];
        stormPage(stormid).wdir_graph = [graphstring '_winddir.png'];
        stormPage(stormid).uprad_graph = [graphstring '_uprad.png'];
        
        %%% RESET THE VARIABLES FOR THE NEXT STORM ID %%%:
        totalprecip = 0; had_trace = 0;
        
        clear oldpres oldtemp oldrh % For the 'does not exist' check.
        clear stormstart stormend s_winddir
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    end
    
    % Checks if the date of the metar date being looked at matches the
    % graph end date of the stormid. Upon execution, the storm page graphs
    % for pressure, temperature, relative humidity, precipitation, wind
    % speed, and wind direction will be generated and saved accordingly.
    if serialdate - graphend(stormid) > 0.0001 && foundgraphstart
        foundgraphstart = 0;
        
        % Get the serial dates of the start and end of the storm, but make
        % the start at the beginning of the hour and the end at the end of
        % the hour.
        stormstart = datevec(date_range(stormid).start);
        stormend = datevec(date_range(stormid).end);
        stormstart(6) = 0; stormend(6) = 0;
        if stormstart(5) ~= 0
            stormstart(5) = 0; stormstart(4) = stormstart(4) + 1;
        end
        if stormend(5) ~= 0
            stormend(5) = 0; stormend(4) = stormend(4) + 1;
        end
        stormstart = datenum(stormstart);
        stormend = datenum(stormend);
        
        % Difficult to implement automation of determining these. Simply
        % look at statistic graphs to determine these by hand.
        stormData(stormid).temp_before = [];
        stormData(stormid).temp_during = [];
        stormData(stormid).pres_before = [];
        stormData(stormid).pres_during = [];
        stormData(stormid).rh_before = [];
        stormData(stormid).rh_during = [];
                
      %%% Set the scale of x-values on the graphs based on the number of
      %%% days being graphed.
        if graphdur(stormid) == 1
            xscale = 2 * (1/24); % 2 hours if 1 day graph
        elseif graphdur(stormid) <= 3
            xscale = 4 * (1/24); % 4 hours if 2/3 day graph
        elseif graphdur(stormid) == 4
            xscale = 8 * (1/24); % 8 hours if 4 day graph
        elseif graphdur(stormid) >= 5
            xscale = 12 * (1/24); % 12 hours if 5+ day graph
        end
        xticks = graphstart(stormid):xscale:graphend(stormid);
        xvalues = graphstart(stormid):(1/24):graphend(stormid);
        
%       if ~isfield(settings, 'is_alta') && (~isfield(settings, 'choose_graphs') || ...
%               (isfield(settings, 'choose_graphs') && isfield(settings, 'graph_pres')))
      %%% Pressure graph %%%:
        if max(pressure) - min(pressure) <= 7
            yscale = 1; % 1 hPa intervals on y-axis
        elseif max(pressure) - min(pressure) <= 14
            yscale = 2; % 2 hPa intervals on y-axis
        elseif max(pressure) - min(pressure) <= 20
            yscale = 3; % 3 hPa intervals on y-axis
        else
            yscale = 4; % Max of 4 hPa intervals on y-axis
        end
        ylims = [floor(min(pressure) - 1) ceil(max(pressure) + 1)];
        yticks = ylims(1):yscale:ylims(2);
        
        figure(1), set(gcf, 'visible', 'off')
        % Graph scatter plot of all pressure values in graph domain.
        ylim(ylims)
        xlim([graphstart(stormid) graphend(stormid)])
        set(gca, 'XTick', xticks)
        set(gca, 'YTick', yticks)
        datetick('x', 'HH', 'keeplimits', 'keepticks')
        hold on
        if length(xvalues) == length(pressure)
            ph = scatter(xvalues, pressure);
            set(gca, 'YGrid', 'on'), box on
            set(ph, 'SizeData', 150)
            set(ph, 'Marker', '.')
            % Graph a second scatter plot of pressure values only in the storm
            % domain. Make the points green to indicate the storm domain.
            ph(2) = scatter(stormstart:(1/24):stormend, ...
                pressure((1 + round(24*(stormstart - graphstart(stormid)))): ...
                (1 + round(24*(stormend - graphstart(stormid))))));
            set(ph(2), 'SizeData', 200)
            set(ph(2), 'MarkerEdgeColor', [0 .8 .4])
            set(ph(2), 'Marker', '.')
            hold off
            
            xlabel(['Time (Hrs, starting at ' datestr(graphstart(stormid), ...
                'mmm dd, yyyy') ')'], AXES_FONT{:})
            ylabel('Pressure (hPa)', AXES_FONT{:})
            title('Pressure', TITLE_FONT{:})
            set(gcf, 'PaperPositionMode', 'manual')
            set(gcf, 'PaperUnits', 'inches')
            set(gcf, 'PaperPosition', [0 0 11 8.5])
            saveas(gcf, ['storms/' stormPage(stormid).hpa_graph])
            clf(gcf)
        else
            fprintf('Error creating presssure graph for storm %d\n',stormid)
        end
        clear ph yscale ylims yticks
%       end
        
      %%% Temperature graph %%%:
      if ~isfield(settings, 'choose_graphs') || ...
              (isfield(settings, 'choose_graphs') && isfield(settings, 'graph_temp'))
          if max(temperature) - min(temperature) <= 7
              yscale = 1; % 1 degree C intervals on y-axis
          elseif max(temperature) - min(temperature) <= 14
              yscale = 2; % 2 degrees C intervals on y-axis
          elseif max(temperature) - min(temperature) <= 20
              yscale = 3; % 3 degrees C intervals on y-axis
          else
              yscale = 4; % Max of 4 degrees C intervals on y-axis
          end
          ylims = [floor(min(temperature) - 1) ceil(max(temperature) + 1)];
          yticks = ylims(1):yscale:ylims(2);
          
          figure(1), set(gcf, 'visible', 'off')
          % Graph scatter plot of all temperature values in graph domain.
          ylim(ylims)
          xlim([graphstart(stormid) graphend(stormid)])
          set(gca, 'XTick', xticks)
          set(gca, 'YTick', yticks)
          datetick('x', 'HH', 'keeplimits', 'keepticks')
          hold on
          if length(xvalues) == length(temperature)
              th = scatter(xvalues, temperature);
              set(gca, 'YGrid', 'on'), box on
              set(th, 'SizeData', 150, 'Marker', '.')
              
              % Graph line plot of all temperature values in graph domain.
              th(3) = plot(xvalues, temperature);
              % Graph a second line plot of temperature values only in the storm
              % domain. Make the line green to indicate the storm domain.
              th(4) = plot(stormstart:(1/24):stormend, ...
                  temperature((1 + round(24*(stormstart - graphstart(stormid)))): ...
                  (1 + round(24*(stormend - graphstart(stormid))))));
              set(th(4), 'LineWidth', 2.5, 'Color', [0 .8 .4])
              % Graph a second scatter plot of temperature values only in the
              % storm domain. Make the points dark green.
              th(2) = scatter(stormstart:(1/24):stormend, ...
                  temperature((1 + round(24*(stormstart - graphstart(stormid)))): ...
                  (1 + round(24*(stormend - graphstart(stormid))))));
              set(th(2), 'SizeData', 200, 'MarkerEdgeColor', [0 .5 0], 'Marker', '.')
              hold off
              
              xlabel(['Time (Hrs, starting at ' datestr(graphstart(stormid), ...
                  'mmm dd, yyyy') ')'], AXES_FONT{:})
              ylabel('Temperature ({\circ}C)', AXES_FONT{:})
              title('Temperature', TITLE_FONT{:})
              set(gcf, 'PaperPositionMode', 'manual')
              set(gcf, 'PaperUnits', 'inches')
              set(gcf, 'PaperPosition', [0 0 11 8.5])
              saveas(gcf, ['storms/' stormPage(stormid).temp_graph])
              clf(gcf)
          else
              fprintf('Error creating temperature graph for storm %d\n',stormid)
          end
        clear th yscale ylims yticks
      end
        
      %%% Wind Speed graph %%%:
      if ~isfield(settings, 'choose_graphs') || ...
              (isfield(settings, 'choose_graphs') && isfield(settings, 'graph_wspd'))
        if max(windspd) <= 5
            yscale = 0.5; % 0.5 m/s intervals on y-axis
        elseif max(windspd) <= 10
            yscale = 1; % 1 m/s intervals on y-axis
        elseif max(windspd) <= 15
            yscale = 1.5; % 1.5 m/s intervals on y-axis
        else
            yscale = 2; % Max of 2 m/s intervals on y-axis
        end
        
%         if isnan(max([gusts.value]))
            ylims = [-1 ceil(max(windspd) + 2)];
%         else
%             ylims = [-1 ceil(max([gusts.value]) + 2)];
%         end
        yticks = 0:yscale:ylims(2);
        
        figure(1), set(gcf, 'visible', 'off')
        % Graph scatter plot of all wind speed values in graph domain.
        ylim(ylims)
        xlim([graphstart(stormid) graphend(stormid)])
        set(gca, 'XTick', xticks)
        set(gca, 'YTick', yticks)
        datetick('x', 'HH', 'keeplimits', 'keepticks')
        hold on
        if length(xvalues) == length(windspd)
            wsh = scatter(xvalues, windspd);
            set(gca, 'YGrid', 'on'), box on
            set(wsh, 'SizeData', 150, 'Marker', '.')
            
            % Find x-values corresponding to the wind gusts
            %         xofgusts = [gusts(~isnan([gusts.value])).date];
            % Graph scatter plot of all wind gusts in graph domain.
            %         wsh(5) = scatter(xofgusts, [gusts(~isnan([gusts.value])).value]);
            %         clear xofgusts
            %         set(wsh(5), 'Marker', '+', 'MarkerEdgeColor', 'r')
            % Graph line plot of all wind speed values in graph domain.
            wsh(3) = plot(xvalues, windspd);
            % Graph a second line plot of wind speed values only in the storm
            % domain. Make the line green to indicate the storm domain.
            wsh(4) = plot(stormstart:(1/24):stormend, ...
                windspd((1 + round(24*(stormstart - graphstart(stormid)))): ...
                (1 + round(24*(stormend - graphstart(stormid))))));
            set(wsh(4), 'LineWidth', 2.5, 'Color', [0 .8 .4])
            % Graph a second scatter plot of wind speed values only in the
            % storm domain. Make the points dark green.
            wsh(2) = scatter(stormstart:(1/24):stormend, ...
                windspd((1 + round(24*(stormstart - graphstart(stormid)))): ...
                (1 + round(24*(stormend - graphstart(stormid))))));
            set(wsh(2), 'SizeData', 200, 'MarkerEdgeColor', [0 .5 0], 'Marker', '.')
            hold off
            
            xlabel(['Time (Hrs, starting at ' datestr(graphstart(stormid), ...
                'mmm dd, yyyy') ')'], AXES_FONT{:})
            ylabel('Wind Speed (m/s)', AXES_FONT{:})
            title('Wind Speed', TITLE_FONT{:})
            set(gcf, 'PaperPositionMode', 'manual')
            set(gcf, 'PaperUnits', 'inches')
            set(gcf, 'PaperPosition', [0 0 11 8.5])
            saveas(gcf, ['storms/' stormPage(stormid).wsp_graph])
            clf(gcf)
        else
            fprintf('Error creating wind speed graph for storm %d\n',stormid)
        end
        clear wsh yscale ylims yticks
      end
        
      %%% Wind Direction graph %%%:
      if ~isfield(settings, 'choose_graphs') || ...
              (isfield(settings, 'choose_graphs') && isfield(settings, 'graph_wdir'))
        ylims = [-1 361];
        yticks = 0:45:360;
        
        figure(1), set(gcf, 'visible', 'off')
        % Graph scatter plot of all wind direction values in graph domain.
        ylim(ylims)
        xlim([graphstart(stormid) graphend(stormid)])
        set(gca, 'XTick', xticks)
        set(gca, 'YTick', yticks)
        datetick('x', 'HH', 'keeplimits', 'keepticks')
        hold on
        if length (xvalues) == length(winddir)
            wdh = scatter(xvalues, winddir);
            set(gca, 'YGrid', 'on'), box on
            set(wdh, 'SizeData', 150, 'Marker', '.')
            
            % Graph second scatter plot of wind direction values only in the
            % storm domain. Make the points dark green.
            wdh(2) = scatter(stormstart:(1/24):stormend, ...
                winddir((1 + round(24*(stormstart - graphstart(stormid)))): ...
                (1 + round(24*(stormend - graphstart(stormid))))));
            set(wdh(2), 'SizeData', 200, 'MarkerEdgeColor', [0 .8 .4], 'Marker', '.')
            hold off
            
            xlabel(['Time (Hrs, starting at ' datestr(graphstart(stormid), ...
                'mmm dd, yyyy') ')'], AXES_FONT{:})
            ylabel('Wind Direction (Compass {\circ})', AXES_FONT{:})
            title('Wind Direction', TITLE_FONT{:})
            set(gcf, 'PaperPositionMode', 'manual')
            set(gcf, 'PaperUnits', 'inches')
            set(gcf, 'PaperPosition', [0 0 11 8.5])
            saveas(gcf, ['storms/' stormPage(stormid).wdir_graph])
            clf(gcf)
        else
            fprintf('Error creating wind direction graph for storm %d\n',stormid)
        end
        clear wdh yscale ylims yticks
      end
        
      %%% Relative Humidity graph %%%:
      if ~isfield(settings, 'choose_graphs') || ...
              (isfield(settings, 'choose_graphs') && isfield(settings, 'graph_relhum'))
        if max(relhumidity) - min(relhumidity) >= 80
            yscale = 10;
            ylims = [0 101];
        else
            yscale = ceil((max(relhumidity) - min(relhumidity)) / 10);
            ylims = [(floor(min(relhumidity) / 10) * 10) 101];
        end
        yticks = ylims(1):yscale:100;
        
        figure(1), set(gcf, 'visible', 'off')
        % Graph scatter plot of all relative humidity values in graph
        % domain.
        ylim(ylims)
        xlim([graphstart(stormid) graphend(stormid)])
        set(gca, 'XTick', xticks)
        set(gca, 'YTick', yticks)
        datetick('x', 'HH', 'keeplimits', 'keepticks')
        hold on
        if length(xvalues) == length(relhumidity)
            rh_h = scatter(xvalues, relhumidity);
            set(gca, 'YGrid', 'on'), box on
            set(rh_h, 'SizeData', 150, 'Marker', '.')
            
            % Graph line plot of all relative humidity values in graph domain.
            rh_h(3) = plot(xvalues, relhumidity);
            % Graph second line plot of relative humidity values only in the
            % storm domain. Make the line green to indicate the storm domain.
            rh_h(4) = plot(stormstart:(1/24):stormend, ...
                relhumidity((1 + round(24*(stormstart - graphstart(stormid)))): ...
                (1 + round(24*(stormend - graphstart(stormid))))));
            set(rh_h(4), 'LineWidth', 2.5, 'Color', [0 .8 .4])
            % Graph second scatter plot of relative humidity values only in the
            % storm domain. Make the points dark green.
            rh_h(2) = scatter(stormstart:(1/24):stormend, ...
                relhumidity((1 + round(24*(stormstart - graphstart(stormid)))): ...
                (1 + round(24*(stormend - graphstart(stormid))))));
            set(rh_h(2), 'SizeData', 200, 'MarkerEdgeColor', [0 .5 0], 'Marker', '.')
            hold off
            
            xlabel(['Time (Hrs, starting at ' datestr(graphstart(stormid), ...
                'mmm dd, yyyy') ')'], AXES_FONT{:})
            ylabel('Relative Humidity (%)', AXES_FONT{:})
            title('Relative Humidity', TITLE_FONT{:})
            set(gcf, 'PaperPositionMode', 'manual')
            set(gcf, 'PaperUnits', 'inches')
            set(gcf, 'PaperPosition', [0 0 11 8.5])
            saveas(gcf, ['storms/' stormPage(stormid).rh_graph])
            clf(gcf)
        else
            fprintf('Error creating humidity graph for storm %d\n',stormid)
        end
        clear rh_h yscale ylims yticks
      end
        
      %%% Precipitation graph %%%:
      if length(xvalues) == length(precip)
          if ~isfield(settings, 'choose_graphs') || ...
                  (isfield(settings, 'choose_graphs') && isfield(settings, 'graph_precip'))
              % Consider possibility of no rain in a storm...
              if isnan(max(precip)) || (max(precip) == 0 && isfield(settings, 'is_alta'))
                  % No precipitation was observed reaching the ground. Do not
                  % make a graph, simply put text in a fake graph and continue.
                  ylims = [0 2.5];
                  xlims = [graphstart(stormid) graphend(stormid)];
                  hold on
                  figure(1), set(gcf, 'visible', 'off')
                  xposition = graphstart(stormid) + ...
                      ((graphend(stormid) - graphstart(stormid)) / 2);
                  ylim(ylims), xlim(xlims), datetick('x','HH','keeplimits','keepticks')
                  txt = text(xposition, 0.05, 'No precipitation reaching the ground.');
                  set(txt, 'FontSize', 18, 'HorizontalAlignment', 'center')
                  hold off
              else
                  if max(precip) == 0
                      yscale = 0.2; ylims = [-0.25 2.05];
                  elseif max(precip) < 2.5
                      yscale = 0.2; ylims = [-0.1 2.5];
                  else
                      yscale = floor(max(precip) * 10) / 100;
                      ylims = [-0.01 (max(precip) + 0.25)];
                  end
                  xlims = [graphstart(stormid) graphend(stormid)];
                  yticks = 0:yscale:ylims(2);
                  
                  figure(1), set(gcf, 'visible', 'off')
                  % Graph line plot of all precipitation values in graph domain.
                  ylim(ylims)
                  xlim(xlims)
                  set(gca, 'XTick', xticks)
                  set(gca, 'YTick', yticks)
                  datetick('x', 'HH', 'keeplimits', 'keepticks')
                  set(gca, 'YGrid', 'on'), box on
                  hold on
                  preciph = bar(xvalues, precip);
                  set(preciph, 'FaceColor', 'r')%, 'LineWidth', 1.5)
                  set(preciph, 'ShowBaseLine', 'off')
                  
                  % Graph second line plot of precipitation values only in the
                  % storm domain. Make the line green to indicate storm domain.
                  preciph(2) = bar((stormstart-(1/24)):(1/24):stormend, ...
                      precip((1 + round(24*((stormstart-(1/24)) - graphstart(stormid)))): ...
                      (1 + round(24*(stormend - graphstart(stormid))))));
%                   set(preciph(2), 'LineWidth', 2.5)
                  set(preciph(2), 'FaceColor', [0 .8 .4])
                  set(preciph(2), 'ShowBaseLine', 'off')
                  
                  % Graph scatter plot of all precipitation values in graph
                  % domain.
%                   preciph(3) = scatter(xvalues, precip);
%                   set(preciph(3), 'MarkerEdgeColor', [.5 0 0], 'Marker', '.', 'SizeData', 100)
                  
                  % Graph second scatter plot of precipitation values only in the
                  % storm domain. Make the points dark green.
%                   preciph(4) = scatter(stormstart:(1/24):stormend, ...
%                       precip((1 + round(24*(stormstart - graphstart(stormid)))): ...
%                       (1 + round(24*(stormend - graphstart(stormid))))));
%                   set(preciph(4), 'MarkerEdgeColor', [0 .5 0], 'Marker', '.', 'SizeData', 150)
                  hold off
              end
              
              xlabel(['Time (Hrs, starting at ' datestr(graphstart(stormid), ...
                  'mmm dd, yyyy') ')'], AXES_FONT{:})
              ylabel('Precipitation (mm)', AXES_FONT{:})
              title('Precipitation', TITLE_FONT{:})
              set(gcf, 'PaperPositionMode', 'manual')
              set(gcf, 'PaperUnits', 'inches')
              set(gcf, 'PaperPosition', [0 0 11 8.5])
              saveas(gcf, ['storms/' stormPage(stormid).uprad_graph])
              clf(gcf)
              clear preciph yscale ylims yticks xlims xposition txt
          end
      else
          fprintf('Error creating precipitaton graph for storm %d\n',stormid)
      end
        
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        stormid = stormid + 1;
        % Reset variables for tracking hourly data:
        clear pressure temperature windspd winddir relhumidity precip gusts
        
        % End program once all dates have been examined.
        if stormid > length(date_range)
            break;
        end
    end
    
    % Executes when in the range of graphstart and graphend for the current
    % stormid. Gets the data necessary for generating the statistics graphs
    % of the storm.
    if foundgraphstart
        graphcounter = graphcounter + 1;

%         if ~isfield(settings, 'is_alta')
            pressure(graphcounter) = metarStruct(counter).pres;
%         end
        temperature(graphcounter) = metarStruct(counter).temp;
        relhumidity(graphcounter) = metarStruct(counter).relhum;
        windspd(graphcounter) = metarStruct(counter).wspd;
%         gusts(graphcounter).value = metarStruct(counter).gust;
%         gusts(graphcounter).date = serialdate;
%         if isfield(settings, 'is_alta')
%             windspdWildcat(graphcounter) = metarStruct(counter).wildcatWspd;
%             gustsWildcat(graphcounter) = metarStruct(counter).wildcatGust;
%         end
        if isnan(metarStruct(counter).wdir) % Variable winds
            winddir(graphcounter) = NaN;
        else
            winddir(graphcounter) = metarStruct(counter).wdir;
        end
        if metarStruct(counter).precip1 == 0 % No precipitation
            precip(graphcounter) = NaN;
        elseif metarStruct(counter).precip1 == -1 % Trace amount
            precip(graphcounter) = 0;
        else
            precip(graphcounter) = metarStruct(counter).precip1;          
        end
        
    % Checks if the metar data being examined matches the date of the graph
    % start. This check is only made if the start of the graph has not been
    % found.
    elseif graphstart(stormid) - serialdate <= 0
        foundgraphstart = 1; % Makes the if-statement above execute.
        graphcounter = 0; % Counts the hours of the graph.
        
        % If not on the first storm in the date_range, the variables to
        % track graph statistics will be re-initialized.
        if stormid > 1
            pressure = zeros(1, (24 * graphdur(stormid)) + 1);
            temperature = zeros(1, (24 * graphdur(stormid)) + 1);
            windspd = zeros(1, (24 * graphdur(stormid)) + 1);
            gusts = struct([]);
            windspdWildcat = zeros(1, (24 * graphdur(stormid)) + 1);
            gustsWildcat = zeros(1, (24 * graphdur(stormid)) + 1);
            winddir = zeros(1, (24 * graphdur(stormid)) + 1);
            relhumidity = zeros(1, (24 * graphdur(stormid)) + 1);
            precip = zeros(1, (24 * graphdur(stormid)) + 1);
        end
        
        % Check if the graphstart of this storm is before the current date
        % of the metar data being read. If true, then will have to go back
        % through the metars field to get the graph variables and, if
        % necessary, to get the storm variables.
        if graphstart(stormid) - serialdate < 0
            while counter > 1 && graphstart(stormid) - metarStruct(counter).date < 0
                counter = counter - 1;
            end
            serialdate = metarStruct(counter).date;
        end
        
        if graphstart(stormid) - serialdate >= (1/24)
            foundgap = 1;
            while graphstart(stormid) - serialdate > 0
                counter = counter + 1;
                serialdate = metarStruct(counter).date;
            end
            dif = round((serialdate - graphstart(stormid)) * 24);
            for k = 1:dif
                graphcounter = graphcounter + 1;
                pressure(graphcounter) = NaN;
                temperature(graphcounter) = NaN;
                relhumidity(graphcounter) = NaN;
                windspd(graphcounter) = NaN;
                winddir(graphcounter) = NaN;
                precip(graphcounter) = NaN;
            end
        elseif graphstart(stormid) - serialdate <= (-1/24)
            dif = round((serialdate - graphstart(stormid)) * 24);
            for k = 1:dif
                graphcounter = graphcounter + 1;
                pressure(graphcounter) = NaN;
                temperature(graphcounter) = NaN;
                relhumidity(graphcounter) = NaN;
                windspd(graphcounter) = NaN;
                winddir(graphcounter) = NaN;
                precip(graphcounter) = NaN;
            end
        else
            foundgap = 0;
        end
        
        % Move the counter back 1 to get the measurement at 00:00 UTC.
        counter = counter - 1;
    end
    
    % Executes when in the current stormid's date_range. Gets the total
    % precipitation measured during the storm.
    if foundstart && ~isfield(settings, 'is_alta')
        % If the storm was just found, move the counter back to the
        % beginning of the storm. Subtract one from graphcounter so that it
        % does not count the same measurement twice.
        stormcounter = stormcounter + 1;        
        
        % Update the total precipitation count
%         if stormcounter > 24 && metarStruct(counter).precip24 > 0
%             totalprecip = totalprecip + metarStruct(counter).precip24;
%             
            % Subtract the 6 hour precip counts that were added to the
            % totalprecip count in the 24 hour window.
%             for j = (counter - 23):counter
%                 if metarStruct(j).precip6 > 0
%                     totalprecip = totalprecip - metarStruct(j).precip6;
%                 end
%             end
%         end
%         if stormcounter > 6 && metarStruct(counter).precip6 > 0
%             totalprecip = totalprecip + metarStruct(counter).precip6;
%             
%             % Subtract the 1 hour precip counts that were added to the
%             % totalprecip count in the 6 hour window.
%             for j = (counter - 5):counter
%                 if metarStruct(j).precip1 > 0
%                     totalprecip = totalprecip - metarStruct(j).precip1;
%                 end
%             end
%         end
        if metarStruct(counter).precip1 > 0                                
            totalprecip = totalprecip + metarStruct(counter).precip1;
            
        elseif metarStruct(counter).precip1 < 0
            had_trace = 1;
            
        end
        
    % Calculates total precip for Alta base met station
    elseif foundstart
        
        stormcounter = stormcounter + 1;
        
        if stormcounter == 1
            beginningprecip = metarStruct(counter).precipY;
        end
                
    % Checks if the date of the metar data being looked at matches or comes
    % within one hour of the storm start time.
    elseif date_range(stormid).start - serialdate < (1/24) && ...
            foundgraphstart >= 0
        foundstart = 1;
        stormcounter = 0;
    end
    
    counter = counter + 1;
    
end

fprintf('...complete.\n')

end

